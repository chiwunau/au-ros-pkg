(require "package://pr2eus/pr2-interface.l")
(load "make-door.l")
(pr2-init)
(setq *init-grasp-cds* (send *pr2* :larm :end-coords :copy-worldcoords))


(defun calc-door-trajectory (&optional (r *door-radius*) (pull t) (axis-up nil))
  (let ((d 0) lis cds-knob (max-angle 120))
    (setq cds-knob (make-cascoords :pos (send *cds-knob-init* :copy-pos)))
    (cond
     ((and pull axis-up)
      (while (< d max-angle)
	(send cds-knob :rotate (deg2rad 1) :z)
	(send cds-knob :translate (float-vector (- (* r (sin (deg2rad 1)))) 0.0 0.0))
	(setq lis (append lis (list (send cds_knob :copy-worldcoords))))
	(setq d (+ d 1))))
     ((and pull (null axis-up))
      (while (< d max-angle)
	(send cds-knob :rotate (deg2rad -1) :z)
	(send cds-knob :translate (float-vector (- (* r (sin (deg2rad 1)))) 0.0 0.0))
	(setq lis (append lis (list (send cds_knob :copy-worldcoords))))
	(setq d (+ d 1))))
       ((and (null pull) axis-up)
      (while (< d max-angle)
	(send cds-knob :rotate (deg2rad 1) :z)
	(send cds-knob :translate (float-vector (* r (sin (deg2rad 1))) 0.0 0.0))
	(setq lis (append lis (list (send cds_knob :copy-worldcoords))))
	(setq d (+ d 1))))
     ((and (null pull) (null axis-up))
      (while (< d max-angle)
	(send cds-knob :rotate (deg2rad -1) :z)
	(send cds-knob :translate (float-vector (* r (sin (deg2rad 1))) 0.0 0.0))
	(setq lis (append lis (list (send cds_knob :copy-worldcoords))))
	(setq d (+ d 1))))
     (t
      (return-from calc-door-trajectory nil)))
    lis))
    
(defun draw-trajectory (cds-lis)
  (let (c)
    (dolist (cds cds-lis)
      (setq c (make-cube 10 10 10))
      (send c :locate (send cds :worldpos))
      (send c :set-color :red)
      (send *irtviewer* :objects c)
      (send *irtviewer* :draw-objects :flush t))))

(defun obtain-real-angle-from-trajectory (cds-lis)
  (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
  (let ((robot-arm-pos (send *pr2* :larm :end-coords :worldpos))
	max-n dis temp)
    (dotimes (i (length cds-lis))
      (setq dis (norm (v- robot-arm-pos (send (elt cds-lis i) :worldpos))))
      (if (or (null temp) (<= dis temp))
	  (progn
	    (setq temp dis)
	    (setq max-n i))))
    (list max-n (elt cds-lis max-n))))
	

;; (defun real-time-angle (r)
;;   (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
;;   (setq *init-grasp-cds* (send *pr2* :larm :end-coords :copy-worldcoords))
;;   (send *irtviewer* :objects (list *pr2*))
;;   (let ((j (calc-door-trajectory r))
;; 	(dr (instance door :init r (elt (send *init-grasp-cds* :worldpos) 2)))
;; 	(c (make-cube 10 10 10))
;; 	ang res)
    
;;     (send (car (send dr :links)) :locate (scale -1 (send dr :end-coords :worldpos)))
;;     (send (car (send dr :links)) :locate (send *pr2* :larm :end-coords :worldpos))

;;     ;(send c :set-color :green)
;;     (send *irtviewer* :objects c dr)
;;     (draw-trajectory j)
;;     (do-until-key 
;;      (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
;;      (setq res (obtain-real-angle-from-trajectory j))
;;      (setq ang (car res))
;;      (send c :locate (cadr res) :world)
;;      (send (car (send dr :joint-list)) :joint-angle (* -1 ang))
;;      (print ang)
;;      (send *irtviewer* :draw-objects :flush t))))
     
      


;; (defun pull-door-single-action (r tgt-deg &optional (axis-up nil))
;;   (send *pr2* :move-to (make-coords) :world)
;;   (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
;;   (let ((d 0)
;; 	(cds_knob (make-cascoords :pos (send *pr2* :larm :end-coords :worldpos)))
;; 	(cds_hand (make-cascoords :coords (send *pr2* :larm :end-coords :copy-worldcoords)))

